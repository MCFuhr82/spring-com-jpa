Resource (Controller) - recurso web correspondente a entidade {...}. 
Recurso para fazer um endpoint para recuperar os {...} cadastrados ou recuperar pelo id.

Sempre que for criar uma entidade Java, criar sempre nessa ordem:
1 - Basic attributes
2 - Associations (instantiate collections)
3 - Constructors
4 - Getter & Setters (collections: only get)
5 - HashCode & equals
6 - Serializable

Depois de criar a entidade, criar um novo pacote chamado controllers.
Após, criar um classe com o mesmo nome da classe entities, com o nome Controller do lado, por exemplo, UserController.
Essa classe criará um recurso web para a entidade {...}

O padrão a ser seguido será o seguinte:
A camada de recurso (resource ou controllers, que se comunicará com o frontend):
APPLICATION ---> RESOURCE LAYER (rest controllers) ----> SERVICE LAYER ----> DATA ACCESS LAYER (data repositories).

1 - Uma camada de recurso, que será os controladores REST, que se comunicarão com a camada de serviços.
2 - A camada de serviços, por sua vez, se comunicarão com a camada de acesso a dados, que serão os data repositories.

---------------------------------------------------------------------------------------------------------------------------

Ao criar a classe, por exemplo, UserController, tem que fazer a anotação @RestController e 
@RequestMapping, indicando o caminho, por exemplo @RequestMapping(value = "/usuarios").

Pode ser criados vários metodos HTTP, um endpoint, para retornar, criar, salvar, atualizar. Por exemplo, o findAll, que buscará todos os usuarios.
O tipo de retorno, é um ResponseEntity, que é um tipo específico do spring para retonar respostas de requisições web.
É um tipo que usar o Generics.
E o return será o ResponseEntity.
	ok() // para retornar a resposta com sucesso no HTTP
	.body(user) // para retonar o corpo da resposta, passando o user como parametro

Ficará assim, usando um usuário mockado como exemplo (criado na mão, com o construtor, para título de exemplo):

@GetMapping // para dizer que é o método GET do HTTP
public ResponseEntity<User> findAll() {
	User user = new User(1L, "Marcelo", "marcelofuhr@gmail.com", "45991011615", "123456")
	return ResponsiEntity.ok().body(user);
}

----------------------------------------------------------------------------
Para trabalhar com o banco de dados em memória H2, criar um arquivo, na pasta resources, com o nome application-test.properties
Após, colocar as propriedades.

Também, informar no arquivo application.properties que o profile ativo é o test. (spring.profiles.active=test)

----------------------------------------------------------------------------
Informar nas entidades criadas (no caso, até agora somente a classe User) a anotação para o JPA  converter os objetos para o modelo relacional. (ORM)

1 - Annotation em cima do nome da classe - @Entity
2 - lembrar de fazer a anotação @Id, para indicar qual atributo será a chave primária
3 - Se for um tipo númerico, como um id, da pra usar a anotação @GeneratedValue para autoincrementar, usando o parametro strategy

-----------------------------------------------------------------------------
Criado uma classe de configuração, para configurar parametros do bando de dados H2, no modelo de teste.
Quando informado no @Profile("test"), quer dizer que essa classe só vai ser usada caso esteja rodando no modo teste, no application.properties.

-----------------------------------------------------------------------------
Criado a interface UserRepository. É uma interface que extende JpaRepository.
É a última camada, que salvará os dados no banco de dados.
Tem que informar o objeto e o tipo <User, Long>, no exemplo de usuários.
A JpaRepository tem vários métodos que serão usados.

Por exemplo, na classe de configuração TestConfig, foi implementado a classe CommandLineRunner.
É uma forma de, quando iniciar a aplicação, essa classe será iniciada, rodando o código que estiver no método void run.
No caso, foi feito a injeçã de dependência da interface UserRepository, usando @Autowired, e após, no método run, intanciado dois usuários, com o construtor.
Após, foi salvo no banco de dados com o método saveAll, passando uma lista de arrays, com o método Arrays.asList(user1, user2);

-----------------------------------------------------------------------------
Criado um novo pacote de serviços, para fazer que a camada de controller, converse com a de serviço, e a de serviço converse com a camada repository.
Apenas um padrão de projeto, para não deixar a camada de controller muito carregada, deixando apenas para fazer as chamadas HTTP.
Qualquer outro tipo de modelo de negócio, poderá ser feito na camada services.

Desta forma, no UserController foi injetado a dependência do UserService com @Autowired.

Foi criado o método para buscar todos no UserService, e também um método para buscar pelo número do ID (usando o Optional)

Na classe UserController: Nesse ultimo caso, lembrar de usar as {} e a anotação @PathVariable

---------------------------------------------------------------------------------
Criado classe Order. Neste momento deu um erro ao usar o @Data do Lombok, com a seguinte mensagem:
Using @Data for JPA entities is not recommended. It can cause severe performance and memory consumption issues.
Por isso, foi excluido @Data e aceitado a correção do IntelliJ. Mas tive que criar um construtor para rodar a instanciação do user, no test config.
Também foi exluído a anotação @NoArgsConstructor, pois estava dando erro.

Adicionado @Table nas entidades, para setar um novo nome para a tabela
Anotação ManyToOne para mapear a chave estrangeira e o JoinColumn para setar o nome da coluna.
Na outra parte, OneToMany usando o mappedBy, dizendo qual atributo esta sendo mapeado para

----------------------------------------------------------------------------------
Criado a classe OrderService, OrderRepository, e OrderController.
Injetado dependencia no testConfig para o orderRepository.
Instanciado pedidos.

Uma anotação importante: quando for fizer associação dos dois lados, ManyToOne e OneToMany, usar anotação @JsonIgnore.
Com isso, não fica num loop infinito, um objeto chamando o outro.

Quando carrega um objeto do lado de muitos para um, automaticamente o JPA carrega o objeto que esta do lado do um.
Mas isso não acontece do lado do um para muitos. É o chamado LAZY LOADING. Isso para não estourar a memória, o tráfego do computador.

-----------------------------------------------------------------------------------
Na enum OrderStatus, foi criado vários 'retornos' possíveis.
Porém, da forma como foi feito, teve que ser criado um atributo, um construtor private,
um método para acessar o construtor, já que o mesmo é private e um método static para buscar]
o OrderStatus através do código int.

Feito isso, foi criado um atributo Integer orderStatus e um Construtor na Classe Order.
Também foi criado manualmente o Getter e Setter para esse atributo, com várias nuances.